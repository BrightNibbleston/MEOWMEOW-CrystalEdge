using Content.Shared._CE.Roadmap;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;
using System.Linq;

namespace Content.Client._CE.Roadmap;

[GenerateTypedNameReferences]
public sealed partial class CERoadmapWindow : DefaultWindow
{
    private IPrototypeManager _prototypeManager = default!;

    public CERoadmapWindow()
    {
        RobustXamlLoader.Load(this);
        var msg = new FormattedMessage();
        msg.AddMarkupOrThrow("[font size=24]ROADMAP [bold]2026[/bold][/font]");
        Header.SetMessage(msg);
    }

    protected override void EnteredTree()
    {
        base.EnteredTree();

        _prototypeManager = IoCManager.Resolve<IPrototypeManager>();
    }

    public void RepopulateRoadmapItems()
    {
        // Clear existing items
        FirstVersion.RemoveAllChildren();
        SecondVersion.RemoveAllChildren();
        ThirdVersion.RemoveAllChildren();

        // Add headers
        FirstVersion.AddChild(new CERoadmapVersionHeader { Text = Loc.GetString("ce-roadmap-header-done") });
        SecondVersion.AddChild(new CERoadmapVersionHeader { Text = Loc.GetString("ce-roadmap-header-in-progress") });
        ThirdVersion.AddChild(new CERoadmapVersionHeader { Text = Loc.GetString("ce-roadmap-header-backlogs") });

        // Get all items and group by status
        var itemsByStatus = _prototypeManager.EnumeratePrototypes<CERoadmapItemPrototype>()
            .GroupBy(p => p.Status)
            .ToDictionary(g => g.Key, g => g.ToList());

        var containers = new Dictionary<RoadmapStatus, Control>
        {
            { RoadmapStatus.Done, FirstVersion },
            { RoadmapStatus.InProgress, SecondVersion },
            { RoadmapStatus.Backlog, ThirdVersion }
        };

        // Process each status
        foreach (var (status, container) in containers)
        {
            if (!itemsByStatus.TryGetValue(status, out var items))
                continue;

            // Group items by category and sort
            var itemsByCategory = items
                .GroupBy(item => _prototypeManager.Index(item.Category))
                .OrderByDescending(g => g.Key.Priority)
                .ThenBy(g => Loc.GetString(g.Key.Title));

            foreach (var categoryGroup in itemsByCategory)
            {
                // Sort items within category alphabetically
                var sortedItems = categoryGroup
                    .OrderBy(item => Loc.GetString(item.Name))
                    .ToList();

                foreach (var prototype in sortedItems)
                {
                    var item = new CERoadmapItem
                    {
                        ItemScope = categoryGroup.Key,
                        HeaderText = Loc.GetString(prototype.Name),
                        Text = prototype.Desc != null ? Loc.GetString(prototype.Desc) : null
                    };

                    container.AddChild(item);
                }
            }
        }
    }
}
